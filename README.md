## vue2--尚品汇实战项目开发

### 第一天

#### 1.开发前相关配置

​		1.1启动项目自动打开浏览器 ----package.json文件夹

​	

```
  "scripts": {
    "serve": "vue-cli-service serve --open", //--open打开浏览器
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
```

​		1.2 eslint校验功能关闭   ----根目录下，创建一个vue.config.js

​		



​		2.3 src文件夹简写方法，配置别名----创建jsconfig.json文件配置@提示【@代表的是src文件加，这样将来文件夹过多，找的时候方便很多】

```
{
    "compilerOptions": {
        "baseUrl": "./",
        "paths": {
            "@/*":["src/*"]
        }
    },
    "exclude":["node_modules","dist"]
}
```

​	

8).路由传参

8.1：路由跳转有两种方式？
比如：A->B
声明式导航：router-link(必须书写to属性)，可以实现路由的跳转
编程式导航：利用的是组件实例的$route.push|replace方法，可以实现路由的跳转。（可以书写一些自己的业务）

8.2：路由传参，参数有两种写法
params参数：属于路由当中的一部分，需要注意，在配置路由的时候，需要占位。
query参数：不属于路径当中的一部分，类似于ajax中的queryString /home?k=v&k=v,不需要占位



------------------------------------
1.编程式路由跳转到当前路由（多数不变），多次执行会抛出havigationDuplicated的警告错误？
--路由跳转有两种形式：声明式导航，编程式导航
--声明式导航没有这类问题的，因为vue-router就是已经处理好了。
1.1为什么编程式导航进行路由跳转的时候就有这种警告？
"vue-router":"^3.5.3":最新的vue-router引入promise
1.2通过给push方法传递响应的成功，失败的回调函数，就可以捕获当前错误，可以解决。

1.3通过底层的代码，可以实现解决错误
this.$router.push({name:'search',params:{keyWord:this.keyWord},query:{k:this.keyWord.toUpperCase()}},()=>{},()=>{})
这种写法是治标不治本，将来在别的组件中push|replace,编程式导航还是有类似错误。

1.4


3.三级联动组件完成
---由于三级联动，在Home,Search,Detail，把三级联动注册为全局组件
好处：只需要注册一次，就可以在项目任何地方使用

4.完成其他组件拆分
HTML,CSS和图片资源




6.axios二次封装

XMLHttpRequest fetch  JQ   axios
6.1 为什么需要进行二次封装axios?
请求拦截器，响应拦截器，：
请求拦截器：可以在发送请求之前可以处理一些业务；
响应拦截器：当服务器数据返回以后，可以处理一些事情

6.2 在项目中经常有API文件加【axios】
接口当中：路径代有/api
baseURL:"/api"


7.接口统一管理

项目很小：完全可以在组件的生命周期函数中发送请求

项目很大：axios.get('xxx')

7.1 跨域问题
什么是跨域：协议，域名，端口号不同请求，称之为跨域
http://localhost:8080/ ---- 前端项目本地服务器
http://39.98.123.211   ----后台服务器
 
JSONP , CROS , 代理



8.nprogess 进度条

start:进度条开始
done: 进度条结束
进度条颜色可以修改的，当然需要修改人家的样式

9.vuex状态管理库

9.1 vuex 是什么？
vuex是官方提供的一个插件，状态管理库，集中式管理项目中组件共用的数据
切记: 并不是所有的项目都有使用vuex，如果项目很小，完全不需要使用vuex，如果项目很大，组件很多数据很多，数据维护很费劲，使用vuex对数据进行集中式管理。
state : 管理数据
actions : 接收事件
mutations : 对数据进行操作。
getters : 管理计算属性
modules : 模块化




10.完成TypeNav三级联动展示数据业务


2)通过JS控制二三级商品分类的展示与隐藏

最开始的时候，是通过CSS样式display:block|none展示与隐藏二三级商品分类
js三元运算符添加动态样式 -----:style="{display: currentIndex == index ? 'block' : 'none'}" 属性值使用引号

3）演示卡顿现象
正常：事件触发非常频繁，而且每一次触发，回调函数都要去执行（如果时间很短，而且回调函数内部有计算，那么很可能出现浏览器卡顿现象）
节流：在规定的时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为极少量触发
防抖：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次

4）函数的防抖与节流


6) 三级联动组件的路由跳转与传递参数
三级联动用户可以点击的：一级分类，二级分类，三级分类，当点击的时候，Home模块跳转到Search模块，一级会把用户选中的产品（产品的名字，产品的ID）在路由跳转的时候，进行传递

路由跳转：
声明式导航：router-link
编程式导航：push|replace

复习：
1）商品分类三级列表由静态变为动态形式【获取服务器数据，解决跨域问题】
2）函数抖动与节流【面试频率很高】
3）路由跳转：声明式导航，（router-link),编程式导航
编程式导航解决这个问题，自定义属性


1)开发Search模块中的TypeNav商品分类(过渡动画效果)
过渡动画：提前组件|元素务必必须有v-if|v-show指令才能进行过渡动画

2)现在我们的产品分类三级列表可以进行优化
在App根组件当中发送请求【根组件中的mounted】只执行一次

3)合并params与query参数

4) 开发Home当中的ListContainer组件和floor组件
https://docschina.org/
这里要知道一件事情，服务器返回的数据（接口）只有商品分类菜单分类数据，对于ListContainer组件和Floor组件数据服务器没有提供
mock数据（模拟）：如果你想mock数据，需要用到一个插件mockjs

使用步骤：
1）在项目当中src文件夹中创建mock文件夹
2）第二步准备JSON数据（mock文件夹中创建响应的JSON文件）---格式化一下，别留空格（否则跑不起来的）
3）把mock数据需要的图片放置在public文件夹中【public文件夹在打包的时候，会把对应的资源原封不动的打包到dist文件夹中
4）创建mockServer.js通过mockjs插件实现模拟数据
5）mockServe.js文件在入口文件中引入（至少需要执行一次，才能模拟数据）


复习：
1）完成商品分类的三级列表路由跳转一级路由参数（合并参数）
2）完成search模块中对于typeNav使用（过渡动画）
3）swiper插件
swiper插件：经常制作轮播图（移动端|pc端页可以使用）
第一步：引入相应依赖包（swiper.js|swiper.css）
第二步：页面中的结构一定要有
第三步：初始化swiper实例，给轮播图添加动态效果
5）mock数据：通过mock.js模块实现的

1)最完美的解决方法：解决轮播图问题
watch + nextTick :数据监听 + 监听已经有的数据变化

$nextTick : 在下次DOM更新 循环结束之后 执行延迟回调，在修改数据之后 立即使用这个方法，获取更新后的DOM
$nextTick : 可以保障页面中的类似结构，经常和很多插件一起使用【都需要DOM存在了再执行】

2)开发floor组件
切记：仓库当中的state的数据格式，不能瞎编，乱写，数据格式取决于服务器返回的数据
2.1：getFloorList这个actions在哪触发，是需要在Home路由当中触发的，我们不能在Floor组件中触发，要使用v-for循环出多个Floor
2.2v-for也可以在自定义标签当中使用
2.3组件通信的方式有哪些？面试频率极高
props：用于父子组件通信
自定义事件： @on,@emit, 可以实现子给父通信
全局事件总线：$bus 全能
pubsub-js:vue当中几乎不用 全能
插槽
vuex

3)在首页当中轮播图拆分为一个共同全局组件
注意：以后在开发项目的时候，如果看到某一个组件在很多地方都使用，你把他变成全局组件，
注册一次，可以在任意地方使用，公用的组件|非路由组件放在components文件夹







***********************************************

重点 ----- 排序
1: 综合,2: 价格 asc: 升序,desc: 降序 




1）分页功能实现
为什么许多项目使用分页功能：比如电商平台同时展示的数据很多【一万加】，采用分页功能
ElementUI是有相应的分页组件，使用起来非常简单，但是我们前台项目目前不用【掌握自定义分页功能】

2）分页器展示：需要那些数据（条件）？
需要知道当前是第几个：pageNo字段代表当前页数
需要知道每一页需要展示多少数据：pageSize字段进行代表
需要整个分页器一共有多少条数据：total字段进行代表---【获取另一条信息：一共多少页】
需要知道分页器连续页码的个数：5|7【奇数】，因为奇数对称（好好看）

pageNo:当前为第几页
pageSize:代表每一页展示多少条数据
total:代表整个分页一共多少条数据
continues:代表分页连续页码个数


5)分页器动态展示？分为上下【中间部分】
v-for:数组|数字|字符串

6）手写分页器

7）开发某个产品的详情页
1：静态组件（详情页的组件，还没有注册为路由组件）
当点击商品的图片时。跳转到详情页面，再路由跳转的时候需要带上产品的ID给详情页面
滚动行为

2.API ---->请求接口

3.vuex---->获取产品详情信息
vuex 中还需要再新增一个模块detail
需要合并到大仓库中


3)购物车
3.1向服务器发起ajax，获取购物车数据，操作vuex三连环，组件获取数据展示数据发现，发请求的时候，获取不到你购物车里的数据，因为服务器不知道你是谁？
3.2UUID临时游客身份
3，3 动态展示购物车
4）修改购物车产品的数量（需要发请求，参数理解）
5）修改产品个数【函数节流】
6）删除某一产品

----删除选中全部产品的操作
注意：没有一次删除很多产品的接口，但是有通过ID可以删除产品的接口【一次删除一个】
Promise.all([p1,p2,p3])
p1|p2|p3:每一个都是Promise对象，如果只有一个Promise失败，如果都成功，返回成功。

7）修改产品状态

通过修改 isChecked值再发请求
8）全选



1)登录业务
1.1注册---通过数据库存储用户信息（名字，密码）
1.2登录---登录成功的时候，后台为了区分用户是谁，服务器下发token【令牌：唯一标识符】
登录接口，做到不完美，一般登录成功后服务器会下发token,前台持久存储token,【带着token找服务器要用户信息进行展示】

2）token令牌理解

vuex存储token不是持久化




复习：
1.完成了登录与注册的静态组件【assets文件夹：组件共用的静态资源，css当中可以书写@符号】
2.表单验证没有处理，等最后一天进行处理
3.vuex存储数据非持久化


1)登录过后首页用户信息的展示
1.1 用户注册完成，用户登录【用户名+密码】向服务器发请求（组件派发action:userLogin)
登录成功获取到token,仓库与仓库当中（非持久化的）路由跳转到home首页

1.2因此在首页当中（mounted)派发action(getUserInfo)获取用户信息，以及动态展示header组件内容

1.3一刷新home首页，获取不到用户信息（token:vuex非持久化存储）

1.4 持久化存储token

1.5存在问题 1. 多个组件展示用户信息需要在每一个组件的mounted中触发，this.$store.dispatch('getUserInfo') 不行

1.6存在问题，2.用户已经登录了，就不应该再进入登录页





2)提交订单

2.1 搞定支付静态组件
2.2 点击提交订单的按钮的时候，还需要向服务器发起一次请求，【把支付一些信息传递给服务器】
2.3 从今天，不使用vuex管理数据

3)获取支付信息（不在使用vuex）
3.1别再生命周期函数中使用async
3.2获取支付信息




1)个人中心
面试时询问是否分装过组件。分页器/日历
个人中心中的；分页器



4)图片懒加载

()=>import(地址)


6)打包上线
npm run build

项目打包后，代码经过压缩加密，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错
有了map就可以向未加密代码一样，准确知道哪里报错
vue.config.js配置
productionSourceMap:false
